# =============================================================================
# Service Accounts for Application Pods
# =============================================================================
# Each microservice gets its own ServiceAccount. When a pod starts, K8s
# automatically mounts a JWT token for this ServiceAccount inside the pod.
#
# The pod sends this token to Vault to prove its identity:
#   "I am user-service running in the retail-app namespace"
#
# Vault verifies this with the K8s API, then returns secrets based on
# the policy bound to that ServiceAccount.
#
# Why separate ServiceAccounts per service?
#   - User Service SA → mapped to "user-service" Vault policy (private + public key)
#   - Order Service SA → mapped to "app-service" Vault policy (public key only)
#   - This enforces least-privilege: each service only gets what it needs.
# =============================================================================

apiVersion: v1
kind: ServiceAccount
metadata:
  name: user-service
  namespace: retail-app
  labels:
    app: user-service

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: order-service
  namespace: retail-app
  labels:
    app: order-service

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: payment-service
  namespace: retail-app
  labels:
    app: payment-service

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: inventory-service
  namespace: retail-app
  labels:
    app: inventory-service

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: frontend
  namespace: retail-app
  labels:
    app: frontend

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: grafana
  namespace: retail-observe
  labels:
    app: grafana
